//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "Help.h"
#include "Main.h"
#include "Pic.h"
#include "Pic2.h"
#include "Girl.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TfrmHelp *frmHelp;
//---------------------------------------------------------------------------
__fastcall TfrmHelp::TfrmHelp(TComponent* Owner)
    : TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TfrmHelp::bExKeyPress(TObject *Sender, char &Key)
{
  if(Key==27)frmHelp->Close();
}
//---------------------------------------------------------------------------
void __fastcall TfrmHelp::FormShow(TObject *Sender)
{
  AnsiString str,emp="";
  m->Lines->Clear();
  switch(frmMain->Tag)
  {
  case 0:
    Height = 197;
    Width = 459;
    Caption = "ASCII";
    bEx->Left = 177;
    bEx->Caption = "Ok";
    bScr1->Visible = false;
    bScr2->Visible = false;
    str="   Программа показывает ASCII-коды символов.";
    m->Lines->Add(str);
    str="   Кнопки со стрелками уменьшают и увеличивают код символа (клавиши), при этом во всех окнах для отображения выводится соответствующая информация.";
    m->Lines->Add(str);
    str="   Крайнее правое окно служит для ввода/отображения символа. Клавиши Влево/Вправо, нажатые в этом окне, изменяют текущий символ.";
    m->Lines->Add(str);
    bEx->SetFocus();
  break;
  case 10:
    Height = 347;
    Width = 471;
    Caption = "Матричный индикатор";
    bEx->Left = 310;
    bEx->Caption = "Оки";
    bScr1->Visible = true;
    bScr1->Width = 113;
    bScr1->Caption = "Screen Short 1";
    bScr2->Visible = true;
    str="  Программа генерирует код символа или рисунка с максимальным разрешением 8*8 и сохраняет полученные данные в файл.";
    m->Lines->Add(str);
    str="  Основное применение сгенерированного кода - использование последнего в программе микроконтроллера для вывода символов на матричный или графический ЖКИ.";
    m->Lines->Add(str);
    str="  Размер символа - выставляется требуемый размер символа. Неиспользуемые пиксели при пересчёте изображения заполняются 0.";
    m->Lines->Add(str);
    str="  Положение:";
    m->Lines->Add(str);
    str="    X - просчёт байтов по горизонтали:";
    m->Lines->Add(str);
    str="    Y - по вертикали.";
    m->Lines->Add(str);
    str="  В применённом мной графическом дисплее использовался вертикальный режим. Можете посмотреть скриншот.";
    m->Lines->Add(str);
    str="  Кнопка ''В массив'' добавляет полученный код символа + коментарий к нему в окошко текстового редактора. По окончании работы его содержимое можно сохранить в файл.";
    m->Lines->Add(str); 
    bEx->SetFocus();
  break;
  case 11: 
    Height = 380;
    Width = 450;
    Caption = "Семисегментный индикатор";
    bEx->Left = 172;
    bEx->Caption = "Угу";
    bScr1->Visible = false;
    bScr2->Visible = false;
    str="  Программа генерирует код для семисегментного индикатора.";
    m->Lines->Add(str);
    str="  ";
    m->Lines->Add(str);
    str="  Сегменты индикатора можно подключать к любому из линий порта. Это бывает актуально при разводке печатной платы, когда для удобства разводки приходится переподключать индикатор. Подключите сегменты индикатора к нужным линиям порта и, когда не останется линий с одинаковыми номерами (одинаковые линии порта подсвечиваются красным цветом), код автоматически пересчитается.  Если вы решили вернуть начальное положение линий порта, нажмите кнопку ''По умолчанию''.";
    m->Lines->Add(str);
    str="  Чтобы зажечь/погасить сегмент индикатора, просто кликните мышкой на его изображение. Одновременно в окошках результата отобразится шестнадцатиричный код изображённого на индикаторе символа. Значения два: для индикатора с общим катодом и с обшим анодом. Выбирайте то, что нужно вам.";
    m->Lines->Add(str);
    str="  Кнопка ''С'' гасит индикатор.";
    m->Lines->Add(str);
    m->SetFocus();
  break;
  case 2:
    Height = 327;
    Width = 432;
    Caption = "UART";
    bEx->Left = 164;
    bEx->Caption = "Ясно";
    bScr1->Visible = false;
    bScr2->Visible = false;
    str="  Утилитка расчитывает скорость передачи по протоколу USART для микроконтроллеров ATmega/ATtiny и константу, заносимую в регистр UBRR, для определённой скорости.";
    m->Lines->Add(str);
    str="  Регистр UBRR имеет 12-ти битный формат, и максимальное значение, которое можно использовать - это 4095, т.е. 0хFFF.";
    m->Lines->Add(str);
    str="  Если задать скорость и вычислить константу, в нижнем окошке появится отклонение полученной скорости передачи от ближайшей стандартной. В теории можно использовать скорости с разбросом +/- 5%. Но рекомендуется использовать значения регистра UBRR, при которых получаемая скорость передачи отличается от требуемого значения более чем на 0,5%. Значения, дающие большее отклонение также можно использовать, однако следует иметь в виду, что при этом снижается помехозащищённость линии передачи.";
    m->Lines->Add(str); 
    bEx->SetFocus();
  break;
  case 3:
    Height = 360;
    Width = 566;
    Caption = "Timers";
    bEx->Left = 231;
    bEx->Caption = "Видал я всё это";
    bScr1->Visible = false;
    bScr2->Visible = false;
    str="                            Расчитываем константы для таймеров.";
    m->Lines->Add(str);
    str="    Указываем частоту микроконтроллера, используемый предделитель и время, либо частоту, которую необходимо получить. При изменении этих параметров константа для регистра TCNT автоматически пересчитывается и в окошке результата расчитывается время/частота, которая получится при использовании полученной константы, и ошибка между требуемым и полученным значением времени.";
    m->Lines->Add(str);
    str="    Если в регистре TCNTH получилось значение, равное 0xFF - мы можем использовать любой, присутствующий на борту микроконтроллера таймер (16-ти или 8-ми битный). При этом для 8-ми битного (Т0, Т2) берём значение регистра TCNTL, а для 16-ти битного (Т1, Т3) - значение обоих регистров. Если в регистре TCNTH присутствует значение, отличное от 0xFF - используем только 16-ти битный таймер (Т1, Т3). Если всё же необходимо использовать 8-ми битный таймер - увеличиваем коэффициент предделителя до тех пор, пока значение регистра TCNTH не станет равным 0xFF.";
    m->Lines->Add(str);
    str="    Когда в обоих регистрах получено значение 0xFF - это означает, что значение времени/частоты, необходимое нам, меньшее частоты тактирования микроконтроллера. Решить эту ситуацию можно путём повышения частоты микроконтроллера или уменьшения коэффициента предделителя.";
    m->Lines->Add(str);
    str="    Следует учесть, что для разных таймеров и вариантов исполнения микроконтроллера используются различные коэффициенты предделителя! О том, какой предделитель можно использовать для данного таймера в данном микроконтроллере, можно прочитать в DataSheet-e на данный микроконтроллер. DataSheet на любой AVR микроконтроллер можно бесплатно скачать с официального сайта фирмы Atmel www.atmel.com.";
    m->Lines->Add(str);  
    m->SetFocus();
  break;
  case 4:  
    Height = 446;
    Width = 655;
    Caption = "BMP";
    bEx->Left = 450;
    bEx->Caption = "Понял";
    bScr1->Visible = true;  
    bScr1->Width = 273;
    bScr1->Caption = "Это было сделано с помощью этой утилитки";
    bScr2->Visible = false;
    str="                                                                               bmp ==> DataArray.c";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    m->Lines->Add(emp);
    str="    Данная утилитка предназначена для перевода монохромного рисунка в массив данных. Полученный массив используется в проекте для микроконтроллера для вывода рисунка на экран графического индикатора типа WG12864A или ему подобном.";
    m->Lines->Add(str);
    str="    Необходимые требования к рисунку:";
    m->Lines->Add(str);
    str="    1. Размер рисунка 128*64 точки;";
    m->Lines->Add(str);
    str="    2. Рисунок должен быть монохромным(чёрно-белым).";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    str="    Для начала необходимо подготовить нужный нам рисунок к требуемому для конвертации виду. Для этого нужно:";
    m->Lines->Add(str);
    str="    1. Открыть требуемый рисунок в Paint-e или ему подобном графическом редакторе;";
    m->Lines->Add(str);
    str="    2. Сделать рисунок монохромным (чёрно-белым);";
    m->Lines->Add(str);
    str="    3. Привести рисунок к размеру: Х=128, Y=64 точки;";
    m->Lines->Add(str);
    str="    4. Открыть подготовленный рисунок данной утилиткой, нажав на акулу, после чего он появится в окне программы;";
    m->Lines->Add(str);
    str="    5. Сконвертировать рисунок, нажав кнопку \"Преобразовать\". Можно проинвертировать изображение в выходном файле, поставив галочку \"Инвертировать\";";
    m->Lines->Add(str);
    str="    6. Вставить готовый массив в свой проект для графического индикатора.";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    m->Lines->Add(emp);
    str="                                                                 Немного о структуре файла BMP";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    str="    Если открыть рисунок в формате BMP блокнотом, мы увидем набор символов:";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    str="BM>Ъ      >   (   Ъ   @   Ъ Ъ      Ъ  8Ъ  8Ъ              яяя яяяяяяяяяяяяяяяяяяяяяЪЪЪяяяяяяяяя ЪЪяяяяяяяяяь  яяяяяяяя    и т.д.";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    str="    Первые 62 символа - это служебная информация. Символы после \"...Ъ  8Ъ  8Ъ            яяя \" (включая последний пробел) - информация о пикселах картинки). Кодируется информация о состоянии пикселей сплошным потоком, начиная с нижней левой позиции картинки. Берутся 8 пикселей в самой нижней строке слева - они составят байт информации. Первый пиксел в картинке (крайний левый) занимает в байте старшую позицию (бит D7), восьмой - младшую (бит D0). Если пиксел чёрный, то он кодируется \"0\", если белый - \"1\". Далее выбираются следующие 8 пикселей с правой стороны от уже выбранных и точно так же кодируются. Если строка заканчивается, мы поднимаемся на строку выше и продолжаем до тех пор, пока все пиксели не будут выбраны и закодированы.";
    m->Lines->Add(str);
    str="    При редактировании этого файла в блокноте он потом уже не откроется как картинка. Но, если вам это нужно, рисунок придётся редактировать с помощью редактора ''HexEdit'' или ''Notepad++'' с включённым плагином Hex-Editor. После такого редактирования файл нормально открывается как картинка.";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    str="                                                                          Что имеем на выходе";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    str="    Дисплей индикатора имеет 8 строк c размерностью каждой строки 8*128 пикселов. Мы имеем возможность рисовать вертикальные палки (|||...|) в определённой строке, создавая тем самым изображение. Каждая палка - байт данных. Верх палки - младший бит, низ - старший бит.";
    m->Lines->Add(str);
    str="    Так вот, в процессе конвертации файла программа вычитывает эти палки, начиная с левого верхнего угла , и заносит эти данные в массив. Т.е. сначала вычитываем первую строку, затем вторую и т.д.";
    m->Lines->Add(str);
    str="    Для общения с индикатором требуется только отсылать ему нужные байты из массива (палки), и говорить, где их рисовать.";
    m->Lines->Add(str);
    m->Lines->Add(emp);
    m->Lines->Add(emp);
    str="                                                                                             Дерзайте";
    m->Lines->Add(str);    
    m->SetFocus();
  break;
  }
}
//---------------------------------------------------------------------------
void __fastcall TfrmHelp::bScr2Click(TObject *Sender)
{
  frmPic2->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TfrmHelp::bScr1Click(TObject *Sender)
{
  if(frmMain->Tag==10)frmPic1->ShowModal();
   else frmGirl->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TfrmHelp::bExClick(TObject *Sender)
{
  frmHelp->Close();
}
//---------------------------------------------------------------------------
void __fastcall TfrmHelp::FormKeyPress(TObject *Sender, char &Key)
{
   if(Key == 27)Close();
}
//---------------------------------------------------------------------------

